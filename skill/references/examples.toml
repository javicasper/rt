# examples.toml — Annotated TOML showing every step type in one place
#
# This is a reference document, not a real filter. It demonstrates syntax for
# every field and step type. Real filters use a subset of these fields.
#
# Processing order (fixed):
#   1. match_output (short-circuit)
#   2. skip (line filtering)
#   3. [[replace]] (per-line transforms)
#   4. [on_success] / [on_failure] (exit-code branch)

# ─── TOP-LEVEL FIELDS ────────────────────────────────────────────────────────

# command: string or array. Supports * wildcard.
command = "example-tool run"
# command = ["example-tool run", "ex run"]        # array form
# command = "example-tool *"                       # wildcard form

# run: override the actual command executed.
run = "example-tool run --machine-readable"

# strip_ansi: strip ANSI escape sequences before pattern matching
strip_ansi = true

# ─── STEP 1: match_output ────────────────────────────────────────────────────

# Whole-output substring checks. Evaluated FIRST. Short-circuits on match.
match_output = [
  { contains = "nothing to do", output = "ok (nothing to do)" },
  { contains = "fatal:", output = "Fatal error detected" },
  { contains = "auth failed", output = "authentication failed" },
  { matches = "^Success", output = "ok" },
]

# ─── STEP 2: skip ────────────────────────────────────────────────────────────

# skip: drop lines matching any regex.
skip = [
  "^\\s*$",               # blank lines
  "^\\s*Downloading ",    # download progress
  "^\\s*Downloaded ",
  "^\\s*Locking ",
  "^\\[=+>\\s*\\]",       # progress bars
]

# ─── STEP 3: [[replace]] ─────────────────────────────────────────────────────

# Per-line regex transforms. Applied in array order.
# {0} = full match, {1}, {2}, ... = capture groups.
# Lines that don't match pass through unchanged.

[[replace]]
# Reformat verbose progress lines
pattern = '^\\s+Compiling (\\S+) v(\\S+)'
output = "compiling {1}@{2}"

[[replace]]
# Reformat table rows: extract columns 1, 3, 4
pattern = '^(\\S+)\\s+\\S+\\s+(\\S+)\\s+(\\S+)'
output = "{1}: {2} → {3}"

# ─── STEP 4: [on_success] / [on_failure] ─────────────────────────────────────

[on_success]
# output: template. {output} = filtered output text.
# head: keep first N lines
# tail: keep last N lines
head = 30
output = "{output}"

[on_failure]
# tail: keep last N lines of filtered output
tail = 20

# ─── VARIANTS ────────────────────────────────────────────────────────────────
# Must appear AFTER all top-level fields.

[[variant]]
name = "special-mode"
detect.files = ["special.config.js", "special.config.ts"]
filter = "example-tool/run-special"
